Time: forwardPacket() takes longest time at O(n), but important part is to make getCount() run in O(logn) time using binary search.
Space: O(n), where n is the max number of packets in the router aka memoryLimit.

class Router {
    Queue<Packet> queue;
    int memoryLimit;
    Set<String> set;
    Map<Integer, List<Packet>> map;

    public Router(int memoryLimit) {
        // newest will be first
        // oldest will be last
        this.queue = new LinkedList<>();
        this.memoryLimit = memoryLimit;
        this.set = new HashSet<>();
        this.map = new HashMap<>();
    }

    // O(1)
    public boolean addPacket(int source, int destination, int timestamp) {
        String key = String.format("%d-%d-%d", source, destination, timestamp);
        if (this.set.contains(key)) {
            return false;
        }
        if (this.queue.size() + 1 > this.memoryLimit) {
            this.forwardPacket();
        }
        this.set.add(key);
        Packet newPacket = new Packet(source, destination, timestamp);
        if (this.map.containsKey(destination)) {
            this.map.get(destination).add(newPacket);
        } else {
            List<Packet> tmp = new ArrayList<>();
            tmp.add(newPacket);
            this.map.put(destination, tmp);
        }
        this.queue.offer(newPacket);
        return true;
    }

    // O(n) worst case because of ArrayList.remove();
    // remove first
    public int[] forwardPacket() {
        Packet removed = this.queue.poll();
        if (removed == null) {
            return new int[0];
        }
        String key = String.format(
                "%d-%d-%d",
                removed.source, removed.destination, removed.timestamp);
        this.set.remove(key);
        this.map.get(removed.destination).remove(removed);
        int[] res = { removed.source, removed.destination, removed.timestamp };
        return res;
    }

    // O(logn)
    public int getCount(int destination, int startTime, int endTime) {
        List<Packet> tmp = this.map.get(destination);
        if (tmp == null)
            return 0;
        int left = lowerBound(tmp, startTime); // first index with timestamp >= startTime
        int right = upperBound(tmp, endTime); // last index with timestamp <= endTime

        if (left > right)
            return 0;
        return right - left + 1;
    }

    // for binary search
    private int lowerBound(List<Packet> queue, int target) {
        int low = 0, high = queue.size() - 1;
        int result = queue.size();
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (queue.get(mid).timestamp >= target) {
                result = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return result;
    }

    // for binary search
    private int upperBound(List<Packet> queue, int target) {
        int low = 0, high = queue.size() - 1;
        int result = -1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (queue.get(mid).timestamp <= target) {
                result = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return result;
    }

}

class Packet {
    int source;
    int destination;
    int timestamp;

    Packet(int source, int destination, int timestamp) {
        this.source = source;
        this.destination = destination;
        this.timestamp = timestamp;
    }

    @Override
    public String toString() {
        return "source: " + this.source + "; destination: " + this.destination + "; timestamp:" + this.timestamp;
    }
}

/**
 * Your Router object will be instantiated and called as such:
 * Router obj = new Router(memoryLimit);
 * boolean param_1 = obj.addPacket(source,destination,timestamp);
 * int[] param_2 = obj.forwardPacket();
 * int param_3 = obj.getCount(destination,startTime,endTime);
 */
