Time: O(m^2 * n), m is the rows, n is the cols
Space: O(m * n), for prefixSum

/**
 * @param {number[][]} mat
 * @return {number}
 */
var numSubmat = function (mat) {
    const ROWS = mat.length, COLS = mat[0].length;

    // compute prefix sum
    // prefix sum of example 1:
    // [0, 0, 0]
    // [1, 0, 1]
    // [2, 1, 1]
    // [3, 2, 1]
    let prefixSum = Array.from({ length: ROWS + 1 }, () => Array(COLS).fill(0));
    for (let i = 1; i < ROWS + 1; i++) {
        for (let j = 0; j < COLS; j++) {
            prefixSum[i][j] = mat[i - 1][j] + prefixSum[i - 1][j];
        }
    }

    // if r1 = 1, and r2 = 5
    // prefix[6][c] - prefix[1][c] must equal to 5
    // since there are a total of 5 cells from r1 to r2
    // and if all are 1s, it should = 5
    function isColumnAllOnes(r1, r2, c) {
        return prefixSum[r2 + 1][c] - prefixSum[r1][c] === r2 - r1 + 1;
    }

    // iterate through each row combinations from r1 to r2
    // r1 is the top row, r2 is the bottom row
    let total = 0;
    for (let r1 = 0; r1 < ROWS; r1++) {
        for (let r2 = r1; r2 < ROWS; r2++) {
            // go column by column
            // checking for consecutive 1s col-wise
            let streak = 0;
            for (let c = 0; c < COLS; c++) {
                if (isColumnAllOnes(r1, r2, c)) {
                    streak++;
                } else {
                    streak = 0;
                }
                total += streak;
            }
        }
    }
    return total;
};
